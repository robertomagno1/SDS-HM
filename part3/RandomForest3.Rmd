---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

```{r}
plot(cars)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Cmd+Option+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Cmd+Shift+K* to preview the HTML file). 

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

```{r}
# Pacchetti
library(dplyr)
library(tidyr)
library(ggplot2)
library(caret)
library(randomForest)

# Carichiamo i dati da hw_data.RData (già definito da te)
load("/Users/jacopocaldana/Downloads/hw_data.RData")

# Filtriamo solo Zone-2 e Zone-3
hw_sub <- hw %>%
  filter(y %in% c("Zone-2","Zone-3")) %>%
  mutate(y = factor(y))

table(hw_sub$y)
```
```{r}
# Funzione per contare picchi (già fornita)
count_peaks <- function(x, threshold = 0) {
  if (length(x) < 3) return(0)
  n_peaks <- 0
  for (i in 2:(length(x)-1)) {
    if (!is.na(x[i]) && !is.na(x[i-1]) && !is.na(x[i+1])) {
      if (x[i] > x[i-1] && x[i] > x[i+1] && x[i] > threshold) {
        n_peaks <- n_peaks + 1
      }
    }
  }
  return(n_peaks)
}

extract_features_advanced2 <- function(data) {
  data %>%
    rowwise() %>%
    mutate(
      sp_values = list(as.numeric(c_across(starts_with("sp.")))),
      al_values = list(as.numeric(c_across(starts_with("al.")))),

      # Statistiche base su speed
      mean_sp = mean(sp_values[[1]], na.rm=TRUE),
      sd_sp   = if (length(na.omit(sp_values[[1]])) < 2) NA_real_ else sd(sp_values[[1]], na.rm=TRUE),
      min_sp  = suppressWarnings(min(sp_values[[1]], na.rm=TRUE)),
      max_sp  = suppressWarnings(max(sp_values[[1]], na.rm=TRUE)),
      range_sp= if (all(is.na(sp_values[[1]]))) NA_real_ else diff(range(sp_values[[1]], na.rm=TRUE)),

      # slope speed (se almeno 2 valori validi)
      slope_sp = if (length(na.omit(sp_values[[1]])) < 2) {
        NA_real_
      } else {
        time_idx <- seq_along(sp_values[[1]])
        coef(lm(sp_values[[1]] ~ time_idx))[2]
      },

      # picchi speed
      peaks_sp = count_peaks(sp_values[[1]], threshold=0),

      # Statistiche base su altitude
      mean_al = mean(al_values[[1]], na.rm=TRUE),
      sd_al   = if (length(na.omit(al_values[[1]])) < 2) NA_real_ else sd(al_values[[1]], na.rm=TRUE),
      min_al  = suppressWarnings(min(al_values[[1]], na.rm=TRUE)),
      max_al  = suppressWarnings(max(al_values[[1]], na.rm=TRUE)),
      range_al= if (all(is.na(al_values[[1]]))) NA_real_ else diff(range(al_values[[1]], na.rm=TRUE)),

      # slope altitude
      slope_al = if (length(na.omit(al_values[[1]])) < 2) {
        NA_real_
      } else {
        time_idx2 <- seq_along(al_values[[1]])
        coef(lm(al_values[[1]] ~ time_idx2))[2]
      },

      # correlazione speed-altitude
      corr_sp_al = if (length(na.omit(sp_values[[1]])) < 2 || length(na.omit(al_values[[1]])) < 2) {
        NA_real_
      } else {
        cor(sp_values[[1]], al_values[[1]], use="complete.obs")
      }
    ) %>%
    ungroup() %>%
    select(-sp_values, -al_values) # via le liste
}
```
```{r}
df_features <- extract_features_advanced2(hw_sub)
df_features$y <- hw_sub$y


dim(df_features)
#head(df_features)
#table(df_features$y)
# Controlla se ci sono ancora NA
cat("Numero totale di NA:", sum(is.na(df_features)), "\n")
```
```{r}
set.seed(123)
train_index <- createDataPartition(df_features$y, p=0.7, list=FALSE)
train_data  <- df_features[train_index, ]
test_data   <- df_features[-train_index, ]

# Assicuriamoci che y sia un fattore con 2 livelli
train_data$y <- factor(train_data$y, levels=c("Zone-2","Zone-3"))
test_data$y  <- factor(test_data$y,  levels=c("Zone-2","Zone-3"))

cat("Train set size:", nrow(train_data), "\n")
cat("Test set size :", nrow(test_data), "\n")
```

```
```{r}
sum(is.na(hw_sub))
```


```{r}
colSums(is.na(hw_sub))
```
```{r}
df_features_test <- extract_features_advanced2(hw_sub)
sum(is.na(df_features_test))
colSums(is.na(df_features_test))
```
```{r}
extract_features_advanced2 <- function(data) {
  data %>%
    rowwise() %>%
    mutate(
      sp_values = list(as.numeric(c_across(starts_with("sp.")))),
      al_values = list(as.numeric(c_across(starts_with("al.")))),

      # Controlliamo che ci siano almeno 2 valori validi prima di calcolare la deviazione standard
      mean_sp = mean(sp_values[[1]], na.rm=TRUE),
      sd_sp   = if (sum(!is.na(sp_values[[1]])) < 2) 0 else sd(sp_values[[1]], na.rm=TRUE),
      range_sp= if (sum(!is.na(sp_values[[1]])) < 2) 0 else diff(range(sp_values[[1]], na.rm=TRUE)),

      # Slope su speed: impostiamo a 0 se ci sono meno di 2 valori validi
      slope_sp = if (sum(!is.na(sp_values[[1]])) < 2) 0 else {
        time_idx <- seq_along(sp_values[[1]])
        coef(lm(sp_values[[1]] ~ time_idx))[2]
      },

      peaks_sp = count_peaks(sp_values[[1]], threshold=0),

      mean_al = mean(al_values[[1]], na.rm=TRUE),
      sd_al   = if (sum(!is.na(al_values[[1]])) < 2) 0 else sd(al_values[[1]], na.rm=TRUE),
      range_al= if (sum(!is.na(al_values[[1]])) < 2) 0 else diff(range(al_values[[1]], na.rm=TRUE)),

      # Slope su altitudine: impostiamo a 0 se ci sono meno di 2 valori validi
      slope_al = if (sum(!is.na(al_values[[1]])) < 2) 0 else {
        time_idx2 <- seq_along(al_values[[1]])
        coef(lm(al_values[[1]] ~ time_idx2))[2]
      },

      # Correlazione speed-altitude: impostiamo a 0 se ci sono meno di 2 valori validi in entrambi
      corr_sp_al = if (sum(!is.na(sp_values[[1]])) < 2 || sum(!is.na(al_values[[1]])) < 2) 0 else cor(sp_values[[1]], al_values[[1]], use="complete.obs")
    ) %>%
    ungroup() %>%
    select(-sp_values, -al_values) # Rimuoviamo le liste per conservare solo i numeri
}
```
```{r}
df_features_fixed <- extract_features_advanced2(hw_sub)

# Controlliamo quanti NA ci sono ora
sum(is.na(df_features_fixed))  # Deve essere molto più basso di prima!

# Se ancora ci sono NA, vediamo dove
colSums(is.na(df_features_fixed))
```
```{r}
# Puliamo il dataset finale
df_features_fixed <- df_features_fixed %>% filter(complete.cases(.))

# Split train-test 70-30
set.seed(123)
train_idx <- createDataPartition(df_features_fixed$y, p=0.7, list=FALSE)
train_data <- df_features_fixed[train_idx, ]
test_data  <- df_features_fixed[-train_idx, ]

# Modello Random Forest
set.seed(123)
rf_model <- randomForest(
  y ~ ., 
  data = train_data,
  ntree = 300,
  mtry = sqrt(ncol(train_data)-1),  # Numero ottimale di feature selezionate
  importance = TRUE
)

# Predizioni e Accuracy
pred_rf <- predict(rf_model, newdata=test_data)
acc_rf  <- mean(pred_rf == test_data$y)
cat("Random Forest Test Accuracy =", acc_rf, "\n")
```
```{r}
friedman_classifier_test_rf <- function(train_df, test_df, B=200, ntree=300, mtry=3) {
  # 1) Fit reale sul train
  set.seed(1234)
  rf_real <- randomForest(y ~ ., data=train_df, ntree=ntree, mtry=mtry)
  pred_real <- predict(rf_real, newdata=test_df)
  acc_real  <- mean(pred_real == test_df$y)
  
  # 2) Permutazioni
  perm_acc <- numeric(B)
  for (b in seq_len(B)) {
    # permutiamo le etichette nel train
    y_perm <- sample(train_df$y)
    train_df_perm <- train_df
    train_df_perm$y <- y_perm
    
    # rialleniamo
    rf_perm <- randomForest(y ~ ., data=train_df_perm, ntree=ntree, mtry=mtry)
    pred_perm <- predict(rf_perm, newdata=test_df)
    perm_acc[b] <- mean(pred_perm == test_df$y)
  }
  
  # 3) p-value: quante perm >= acc_real
  p_value <- (1 + sum(perm_acc >= acc_real)) / (B+1)
  list(acc_real=acc_real, perm_acc=perm_acc, p_value=p_value)
}
```
```{r}
set.seed(999)
res_friedman <- friedman_classifier_test_rf(
  train_data, 
  test_data, 
  B=200,   # Numero di permutazioni
  ntree=300,
  mtry=3
)

cat("Friedman RF - Accuracy reale =", res_friedman$acc_real, "\n")
cat("Friedman RF - p-value =", res_friedman$p_value, "\n")

# Plot distribuzione accuracy permutate
hist(res_friedman$perm_acc, breaks=20,
     main="Permutation Distribution (RF)",
     xlab="Accuracy (permuted)")
abline(v=res_friedman$acc_real, col="red", lwd=2)
```


