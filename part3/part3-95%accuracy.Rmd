---
title: "Feature Extraction and Classification"
author: "Data Scientist"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

# **Introduction**
This RMarkdown document applies **Friedman’s Classifier-Based Two-Sample Test** to HR data. We extract statistical features from a dataset containing **speed and altitude** data and use them for classification and hypothesis testing.

## **1. Load Required Libraries**
```{r load-libraries}
library(dplyr)      # Data manipulation
library(moments)    # Skewness & kurtosis
library(ggplot2)    # Visualization
library(caret)      # Classification
library(glmnet)     # Regularized logistic regression
library(tidyr)      # Handling missing values
library(stats)      # Statistical tests
library(corrplot)   # Correlation analysis
library(e1071)      # Confusion matrix
```

## **2. Load Data**
```{r load-data}
# Load dataset (Ensure hw is loaded properly)
# hw <- read.csv("your_data.csv")  # Uncomment if needed
head(hw)  # Display first rows
```

## **3. Define Feature Extraction Function**
```{r feature-extraction}
extract_features_one <- function(row_data, speed_cols, altitude_cols) {
  sp_values <- as.numeric(row_data[speed_cols])
  al_values <- as.numeric(row_data[altitude_cols])
  
  if (all(is.na(sp_values)) | all(is.na(al_values))) return(NULL)  # Handle NA rows
  
  mean_sp   <- mean(sp_values, na.rm=TRUE)
  median_sp <- median(sp_values, na.rm=TRUE)
  sd_sp     <- sd(sp_values, na.rm=TRUE)
  min_sp    <- min(sp_values, na.rm=TRUE)
  max_sp    <- max(sp_values, na.rm=TRUE)
  range_sp  <- max_sp - min_sp
  diff_sp   <- sp_values[length(sp_values)] - sp_values[1]
  
  time_idx   <- seq_along(sp_values)
  lm_sp      <- lm(sp_values ~ time_idx)
  slope_sp   <- coef(lm_sp)[2]  
  
  mean_al   <- mean(al_values, na.rm=TRUE)
  median_al <- median(al_values, na.rm=TRUE)
  sd_al     <- sd(al_values, na.rm=TRUE)
  min_al    <- min(al_values, na.rm=TRUE)
  max_al    <- max(al_values, na.rm=TRUE)
  range_al  <- max_al - min_al
  diff_al   <- al_values[length(al_values)] - al_values[1]
  
  time_idx2  <- seq_along(al_values)
  lm_al      <- lm(al_values ~ time_idx2)
  slope_al   <- coef(lm_al)[2]
  
  corr_sp_al <- cor(sp_values, al_values, use="complete.obs")
  
  feats <- data.frame(
    mean_sp = mean_sp,
    median_sp = median_sp,
    sd_sp = sd_sp,
    min_sp = min_sp,
    max_sp = max_sp,
    range_sp = range_sp,
    diff_sp = diff_sp,
    slope_sp = slope_sp,
    mean_al = mean_al,
    median_al = median_al,
    sd_al = sd_al,
    min_al = min_al,
    max_al = max_al,
    range_al = range_al,
    diff_al = diff_al,
    slope_al = slope_al,
    corr_sp_al = corr_sp_al
  )
  
  return(feats)
}
```

## **4. Apply Feature Extraction**
```{r apply-features}
speed_cols <- grep("sp.", names(hw), value = TRUE)
altitude_cols <- grep("al.", names(hw), value = TRUE)

dataset_features1 <- lapply(1:nrow(hw), function(i) extract_features_one(hw[i, ], speed_cols, altitude_cols))
dataset_features1 <- do.call(rbind, dataset_features1) %>% drop_na()  # Remove any NA rows
dataset_features2 <- dataset_features1  # If applying same feature set
```

## **5. Train a Logistic Regression Classifier and Compute Confusion Matrix**
```{r classification}
dataset_features1$y <- as.factor(hw$y[1:nrow(dataset_features1)])
dataset_features2$y <- as.factor(hw$y[1:nrow(dataset_features2)])

y1 <- as.numeric(dataset_features1$y) - 1
y2 <- as.numeric(dataset_features2$y) - 1

x1 <- model.matrix(~ ., data = dataset_features1)[, -1]
x2 <- model.matrix(~ ., data = dataset_features2)[, -1]

# Ensure x and y have matching rows
if (nrow(x1) == length(y1) & nrow(x2) == length(y2)) {
  cv_model1 <- cv.glmnet(x1, y1, family = "multinomial")
  cv_model2 <- cv.glmnet(x2, y2, family = "multinomial")

  pred1 <- predict(cv_model1, x1, type = "class")
  pred2 <- predict(cv_model2, x2, type = "class")
  confusionMatrix(as.factor(pred1), as.factor(y1))
  confusionMatrix(as.factor(pred2), as.factor(y2))
} else {
  print("Mismatch in number of rows between features and labels!")
}
```

## **6. Perform Friedman’s Classifier-Based Two-Sample Test**
```{r friedman-test}
friedman.test(as.matrix(dataset_features1[, -1]), g = dataset_features1$y)
friedman.test(as.matrix(dataset_features2[, -1]), g = dataset_features2$y)
```
